<?php

namespace App\Extensions\Form\ConfigurableForm;

use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\Form\FormError;

use App\Plugins\Form\FormInterface;
use App\Extensions\Form\ConfigurableForm\Exception\ValidationException;

/**
 * Abstract class for defining a configurable form
 */
abstract class FormBase implements FormInterface
{
    use ServerValidationTrait;

    /**
     * Form factory object
     *
     * @var object
     */
    private $factory;

    /**
     * Overridable product
     *
     * @var string
     */
    protected $product;

    public function __construct($product = null)
    {
        // If product property has a default value in parent class, do not replace it with NULL.
        if (!is_null($product)) {
            $this->product = $product;
        }
    }

    /**
     * Defines the form ID
     *
     * @return string
     */
    abstract public function getFormId();

    /**
     * Alters the form definition generated by the form builder
     *
     * @param array $definition
     * @param array $data
     *
     * @return array
     */
    abstract public function alterFormDefinition($definition, $data, $options);

    /**
     * Container dependency injection
     */
    public function setContainer($container)
    {
        $this->factory = $container->get('form_builder_factory');
        $this->form = $container->get('config_form_fetcher');

        if ($this->product) {
            $this->form = $this->form->withProduct($this->product);
        }
    }

    /**
     * @{inheritdoc}
     */
    public function getForm(FormBuilderInterface $form, $options)
    {
        $id = $this->getFormId();

        // check if the form can be constructed using a static form definition
        if (method_exists($this, 'getFormDefinition')) {
            $data = $this->getFormDefinition($options);
        } else {
            $data = $this->form->getDataById($id);
        }

        $builder = $this->factory->createBuilder('configurable_form');

        $name = $form->getName();

        $definition = $builder->getFormDefinition($name, $data['fields'], $options);

        // provide alter for definitions
        if (method_exists($this, 'alterFormDefinition')) {
            $formDefinition = $definition[$name];
            $definition[$name] = $this->alterFormDefinition($formDefinition, $data, $options);
        }

        return $builder->createFormByDefinition($definition, $form);
    }

    /**
     * Defines how a validation error will be handled
     *
     * @param object $form The current form object
     * @param array $constraints The list of all validation constraints
     */
    public function onValidateError($form, $constraints)
    {
        foreach ($constraints as $field => $errors) {
            foreach ($errors as $error) {
                $form->addError(new FormError($error));
            }
        }

        throw new ValidationException("Failed server side validation for form $id");
    }

    /**
     * Defines how a validation exception will be handled
     *
     * @param object $form The current form object
     * @param array $constraints The list of all validation constraints
     * @param Exception $e
     */
    public function onValidateException($form, $constraints, $e)
    {
        $message = "Form server side validation has failed";

        $form->addError(new FormError($message));

        throw $e;
    }

    /**
     * Converts pipe separated multiline values to valid choices array
     *
     * @param string $string
     *
     * @return array
     */
    protected function pipeToChoices($string)
    {
        $result = [];
        $arrays = explode(PHP_EOL, $string);

        foreach ($arrays as $array) {
            $explode = explode('|', $array);

            if (count($explode) === 2) {
                list($key, $value) = $explode;
                $result[trim($value)] = $key;
            }
        }

        return $result;
    }

    /**
     * Gets the validator data base on form ID
     *
     * @param string $formId
     * @param array $options options to be passed on form definition
     *
     * @return array validator data
     */
    public function getValidatorsByFormId($formId, $options = [])
    {
        $name = $this->getFormName($formId);
        $data = $this->form->getDataById($this->getFormId());
        $builder = $this->factory->createBuilder('configurable_form');
        $definition = $builder->getFormDefinition($name, $data['fields'], $options);

        return $builder->getValidationConfigurations($definition);
    }

    /**
     * Gets the class name of the formId
     *
     * @param string $formId
     *
     * @return string
     */
    private function getFormName($formId)
    {
        return (new \ReflectionClass($formId))->getShortName();
    }

    /**
     * Move Field Attribute.
     *
     * @param array $definition
     * @param string $fieldKey
     * @param string $attrKey
     * @param string $attrName
     */
    protected function moveAttribute(&$definition, $fieldKey, $attrKey, $attrName)
    {
        if (isset($definition[$fieldKey]['options'][$attrKey])) {
            $value = $definition[$fieldKey]['options'][$attrKey];
            if ($value) {
                $definition[$fieldKey]['options']['attr'][$attrName] = $value;
            }
            unset($definition[$fieldKey]['options'][$attrKey]);
        }
    }
}
